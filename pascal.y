%{
//author:liang_jk student_id:2016202101
//generated by bison3.0.4

#include<cstdio>
#include<cstring>
#include<vector>
#include"pascal.h"
#include"code.h"

using namespace std;

instruction code[CODESIZE];
int code_cnt;

int yylex(void);

int error_flag=0;

FILE*syntax;
extern FILE*yyin;

void yyerror (char const * msg)
{
	extern int yylineno;
	error_flag=1;
	fprintf(stderr,"Error: %s encountered at line number:%d\n", msg, yylineno);
	return;
}

struct int_node{
	int data;
	int_node*next;
	int_node(int a=0,int_node*b=NULL):data(a),next(b){}
};

struct id_node{
	char id[16];
	id_node*next;
	id_node(){}
	id_node(const char*a,id_node*b):next(b){strcpy(id,a);}
};

struct para_node{
	int flag,type;
	void*type_addr;
	para_node*next;
	para_node(int a=0,int b=0,void*c=NULL,para_node*d=NULL):flag(a),type(b),type_addr(c),next(d){}
};
typedef para_node* para_list;

struct label_node{
	int id;
	int addr;
	label_node* next;
	label_node(int a=0,int b=-1,label_node*c=NULL):id(a),addr(b),next(c){}
};
typedef label_node* label_list;
label_node* lookup(label_list now,int id)
{
	if(now==NULL)return NULL;
	if(now->id==id)return now;
	return lookup(now->next,id);
}

struct const_node{
	char id[16];
	int type;//Integer 1 Real 2
	int val;
	double double_val;
	const_node* next;
	const_node(){}
	const_node(const char*a,int b,int c,const_node*d):type(b),val(c),next(d){strcpy(id,a);}
	const_node(const char*a,int b,double c,const_node*d):type(b),double_val(c),next(d){strcpy(id,a);}
	const_node(const char*a,int b,int c,double d,const_node*e):type(b),val(c),double_val(d),next(e){strcpy(id,a);}
};
typedef const_node* const_list;
const_node* lookup(const_list now,const char*id)
{
	if(now==NULL)return NULL;
	if(strcmp(now->id,id)==0)return now;
	return lookup(now->next,id);
}

int get_size(int type,void*type_addr);

struct type_node{
	char id[16];
	int type;//Pointer -x Integer 1 Real 2 Char 3 Boolean 4 Array 5 Record 6
	void* type_addr;
	type_node* next;
	type_node(){}
	type_node(const char*a,int b,void*c,type_node*d):type(b),type_addr(c),next(d){strcpy(id,a);}
};
typedef type_node* type_list;
type_node* lookup(type_list now,const char*id)
{
	if(now==NULL)return NULL;
	if(strcmp(now->id,id)==0)return now;
	return lookup(now->next,id);
}

struct array_node{
	int dim,size;
	int type;
	void* type_addr;
	vector<int> index;
	array_node* next;
	array_node(int a=0,int b=0,void*c=NULL,int_node*d=NULL,array_node*e=NULL):dim(a),type(b),type_addr(c),next(e)
		{
		int_node*tmp;
		size=get_size(type,type_addr);
		for(;d;d=tmp)
			{
			index.push_back(d->data);
			int up=d->data;
			tmp=d->next;
			delete d;
			d=tmp;
			index.push_back(d->data);
			int low=d->data;
			tmp=d->next;
			delete d;
			size*=(up-low+1);
			}
		}
};
typedef array_node* array_list;

struct var_node{
	char id[16];
	int type;
	void* type_addr;
	int offset;
	var_node* next;
	var_node(){}
	var_node(const char*a,int b,void*c,int d,var_node*e):type(b),type_addr(c),offset(d),next(e){strcpy(id,a);}	
};
typedef var_node* var_list;
var_node* lookup(var_list now,const char*id)
{
	if(now==NULL)return NULL;
	if(strcmp(now->id,id)==0)return now;
	return lookup(now->next,id);
}

struct record_node{
	var_list field;
	int size;
	record_node* next;
	record_node(var_list a=NULL,record_node*b=NULL):field(a),next(b)
		{
		size=0;
		for(var_node*now=field;now;now=now->next)size+=get_size(now->type,now->type_addr);
		}
};
typedef record_node* record_list;

int get_size(int type,void*type_addr)
{
	if(type<0)return 2;
	else if(type==1)return 1;
	else if(type==2)return 2;
	else if(type==3)return 1;
	else if(type==4)return 1;
	else if(type==5)return ((array_node*)type_addr)->size;
	else if(type==6)return ((record_node*)type_addr)->size;
	yyerror("unknown type");
	return 0;
}

struct flags;

struct func_node{
	char id[16];
	int res_type;
	void* type_addr;
	int para_num;
	para_list para;
	int addr;
	func_node* next;
	func_node(){}
	func_node(const char*a,int b,void*c,int d,para_list e,int f,func_node*g):res_type(b),type_addr(c),para_num(d),para(e),addr(f),next(g){strcpy(id,a);}
};
typedef func_node* func_list;
func_node* lookup(func_list now,const char*id)
{
	if(now==NULL)return NULL;
	if(strcmp(now->id,id)==0)return now;
	return lookup(now->next,id);
}

struct flags{
	label_list label;
	const_list con;
	type_list type;
	array_list arr;
	record_list rec;
	var_list var;
	func_list func;
	flags*next;
	flags(flags*a=NULL):next(a)
		{
		label=NULL;
		con=NULL;
		type=NULL;
		arr=NULL;
		rec=NULL;
		var=NULL;
		func==NULL;
		}
	flags(flags*a,flags*b):next(b)
		{
		label=a->label;
		con=a->con;
		type=a->type;
		arr=a->arr;
		rec=a->rec;
		var=a->var;
		func=a->func;
		}
};

flags*global;
var_list rec_flags;

%}

%union{
	int val;
	double double_val;
	char id[16];
	pip pair;
	four var;
}

%nonassoc EQUAL NOT_EQUAL L_OR_E G_OR_E LESS GREATER
%left PLUS MINUS OR XOR
%left TIME DIVIDE DIV MOD AND
%right NOT
%right HAT
%left DOT

%token VAR ARRAY CONST RECORD
%token BEGINN ENDD
%token CASE OF
%token TO DOWNTO
%token IF ELSE
%token <val> THEN
%token UNTIL
%token <val> WHILE DO REPEAT FOR
%token PROGRAM FUNCTION PROCEDURE CALL
%token LABEL GOTO
%token NIL
%token TYPE

%token <val> BOOL
%token <val> CHAR
%token <val> INTEGER
%token <double_val> REAL
%token <id> ID

%token INTEGER_TYPE REAL_TYPE CHAR_TYPE BOOL_TYPE

%token INPUT OUTPUT
%token ABS
%token ARCTAN COS SIN
%token CHR ORD
%token EOFF EOLN
%token EXP LN
%token ODD
%token PRED SUCC
%token ROUND TRUNC SQRT SQR
%token READ READLN WRITE WRITELN
%token NEW

%token LB1 RB1 LB2 RB2
%token ASSIGN
%token COMMER
%token DOT
%token COLON
%token DDOT
%token SEMI

%token ERROR LONGID

%start startsyn

%type <val> sign
%type <pair> type pointer_type type_id array_type record_type
%type <pair> index_list id_list para_list para_df actual_para_list
%type <val> integer_const

%type <pair> expr simple_expr term_list term factor function_expr
%type <var> variable
%type <pair> integer_const_list

%type <val> pro_head func_head

%type <val> case_df
%type <pair> case_list

%type <val> expr_list
%%

startsyn : {global=new flags;} program_head block DOT {code[code_cnt++]=instruction(JMP,0,0);fprintf(syntax,"Program_head + Block + Dot => Program\n");}
	;

program_head : PROGRAM ID SEMI {fprintf(syntax,"\"PROGRAM\" + Identifier + ; => Program_head\n");}
	| {fprintf(syntax,"Program_head is empty.\n");}
	;

block :
	declaration
		{
		int off;
		if(global->var)
			off=global->var->offset+get_size(global->var->type,global->var->type_addr);
		else
			off=0;
		code[code_cnt++]=instruction(INI,0,off);
		}
	statement
		{
		fprintf(syntax,"Declaration-part + Statement-part => Block\n");
		}
	;

declaration : label_dc const_dc type_dc var_dc pro_func_dc {fprintf(syntax,"Label-part + Const-part + Type-part + Var-part + Procedure/Function-part => Declaration\n");}
	;

label_dc : LABEL label_list SEMI {fprintf(syntax,"\"LABEL\" + Label-list + ; => Label_declaration\n");}
	| {fprintf(syntax,"Label_declaration is empty.\n");}
	;

label_list : label {fprintf(syntax,"Label => Label-list\n");}
	| label COMMER label_list {fprintf(syntax,"Label + , + Label-list => Label-list\n");}
	;

label : 
	INTEGER 
		{
		int check=1;
		for(flags*fl=global;fl;fl=fl->next)
			if(lookup(fl->label,$1))
				{
				yyerror("label used");
				check=0;
				break;
				}
		if(check)global->label=new label_node($1,-1,global->label);
		fprintf(syntax,"Integer => Label\n");
		}
	;

const_dc : CONST const_list {fprintf(syntax,"\"CONST\" + Const_definition-list => Const_declaration\n");}
	| {fprintf(syntax,"Const_declaration is empty.\n");}
	;

const_list : const_df SEMI {fprintf(syntax,"Const_definition => Const_definition-list + ;\n");}
	| const_df COMMER const_list {fprintf(syntax,"Const_definition + , + Const_definition-list => Const_definition-list\n");}
	| const_df SEMI const_list {fprintf(syntax,"Const_definition + ; + Const_definition-list => Const_definition-list\n");}
	;

const_df :
	ID EQUAL sign INTEGER
		{
		int check=1;
		for(flags*fl=global;fl;fl=fl->next)
			{
			if(lookup(fl->con,$1))
				{
				yyerror("name used in const");
				check=0;
				break;
				}
			if(lookup(fl->var,$1))
				{
				yyerror("name used in variable");
				check=0;
				break;
				}
			if(lookup(fl->func,$1))
				{
				yyerror("name used in procedure/function");
				check=0;
				break;
				}
			}
		if(check)global->con=new const_node($1,1,$3*$4,global->con);
		fprintf(syntax,"Identifier + = + Sign + Integer => Const_definition\n");
		}
	|
	ID EQUAL sign REAL
		{
		int check=1;
		for(flags*fl=global;fl;fl=fl->next)
			{
			if(lookup(fl->con,$1))
				{
				yyerror("name used in const");
				check=0;
				break;
				}
			if(lookup(fl->var,$1))
				{
				yyerror("name used in variable");
				check=0;
				break;
				}
			if(lookup(fl->func,$1))
				{
				yyerror("name used in procedure/function");
				check=0;
				break;
				}
			}
		if(check)global->con=new const_node($1,2,$3*$4,global->con);
		fprintf(syntax,"Identifier + = + Sign + Real => Const_definition\n");
		}
	|
	ID EQUAL sign ID
		{
		int check=1;
		for(flags*fl=global;fl;fl=fl->next)
			{
			if(lookup(fl->con,$1))
				{
				yyerror("name used in const");
				check=0;
				break;
				}
			if(lookup(fl->var,$1))
				{
				yyerror("name used in variable");
				check=0;
				break;
				}
			if(lookup(fl->func,$1))
				{
				yyerror("name used in procedure/function");
				check=0;
				break;
				}
			}
		if(check)
			{
			const_node*tmp=NULL;
			for(flags*fl=global;fl;fl=fl->next)
				{
				tmp=lookup(fl->con,$4);
				if(tmp)break;
				}
			if(tmp)
				global->con=new const_node($1,tmp->type,$3*tmp->val,$3*tmp->double_val,global->con);
			else
				yyerror("no such const");
			}
		fprintf(syntax,"Const_definition => Identifier + = + Sign + Const_identifier\n");
		}
	;

sign :PLUS {$$=1;fprintf(syntax,"+ => Sign\n");} 
	| MINUS {$$=-1;fprintf(syntax,"- => Sign\n");} 
	| {$$=1;fprintf(syntax,"Sign is empty.\n");}
	;

type_dc : TYPE type_list {fprintf(syntax,"\"TYPE\" + Type-list => Type_declaration\n");}
	| {fprintf(syntax,"Type_declaration is empty.\n");}
	;

type_list : type_df SEMI {fprintf(syntax,"Type_definition => Type->list + ;\n");}
	| type_df COMMER type_list {fprintf(syntax,"Type_definition + , + Type_list => Type-list\n");}
	| type_df SEMI type_list {fprintf(syntax,"Type_definition + ; + Type_list => Type-list\n");}
	;

type_df :
	ID EQUAL type
		{
		int check=1;
		for(flags*fl=global;fl;fl=fl->next)
			if(lookup(fl->type,$1))
				{
				yyerror("name used in type");
				check=0;
				break;
				}
		if(check)global->type=new type_node($1,$3.first,$3.second,global->type);
		fprintf(syntax,"Identifier + = + Type => Type_definition\n");
		}
	;

type : pointer_type {fprintf(syntax,"Pointer-type => Type\n");}
	| type_id {fprintf(syntax,"Type_identifier => Type\n");}
	| array_type {fprintf(syntax,"Array-type => Type\n");}
	| record_type {fprintf(syntax,"Record-type => Type\n");}
	;

pointer_type :
	HAT type_id
		{
		$$.first=-$2.first;
		$$.second=$2.second;
		fprintf(syntax,"^ + Base_type_identifier => Pointer-type\n");
		}
	;

type_id :
	ID
		{
		type_node*tmp=NULL;
		for(flags*fl=global;fl;fl=fl->next)
			{
			tmp=lookup(fl->type,$1);
			if(tmp)break;
			}
		if(tmp)
			{
			$$.first=tmp->type;
			$$.second=tmp->type_addr;
			}
		else
			yyerror("no such type");
		fprintf(syntax,"Identifier => Type_identifier\n");
		}
	| INTEGER_TYPE {$$.first=1;$$.second=NULL;fprintf(syntax,"Integer_type => Type_identifier\n");}
	| REAL_TYPE {$$.first=2;$$.second=NULL;fprintf(syntax,"Real_type => Type_identifier\n");}
	| CHAR_TYPE {$$.first=3;$$.second=NULL;fprintf(syntax,"Char_type => Type_identifier\n");}
	| BOOL_TYPE {$$.first=4;$$.second=NULL;fprintf(syntax,"Boolean_type => Type_identifier\n");}
	;

array_type :
	ARRAY LB2 index_list RB2 OF type
		{
		global->arr=new array_node($3.first,$6.first,$6.second,(int_node*)($3.second),global->arr);
		$$.first=5;
		$$.second=global->arr;
		fprintf(syntax,"\"ARRAY\" + [ + Index-list + ] + \"OF\" + Element-type => Array_type\n");
		}
	;

index_list :
	integer_const DDOT integer_const
		{
		if($3<$1)
			yyerror("second index is smaller thar first index of array");
		else
			{
			int_node*tmp=new int_node($1,NULL);
			$$.second=new int_node($3,tmp);
			$$.first=1;
			}
		fprintf(syntax,"Integer_const + .. + Integer_const => Index-list\n");
		}
	|
	integer_const DDOT integer_const COMMER index_list
		{
		int_node*tmp=new int_node($1,(int_node*)($5.second));
		$$.second=new int_node($3,tmp);
		$$.first=$5.first+1;
		fprintf(syntax,"Integer_const + .. + Integer_const + , + index-list => Index-list\n");
		}
	;

integer_const :
	sign INTEGER
		{
		$$=$1*$2;
		fprintf(syntax,"Sign + Integer => Integer_const\n");
		}
	|
	sign ID
		{
		const_node*tmp=NULL;
		for(flags*fl=global;fl;fl=fl->next)
			{
			tmp=lookup(fl->con,$2);
			if(tmp)break;
			}
		if(tmp==NULL)
			yyerror("no such const");
		else if(tmp->type!=1)
			yyerror("not a integer const");
		else
			$$=tmp->val*$1;
		fprintf(syntax,"Sign + Identifier => Integer_const\n");
		}
	;

record_type :
	RECORD
		{
		rec_flags=global->var;
		global->var=NULL;
		}
	var_list ENDD
		{
		global->rec=new record_node(global->var,global->rec);
		global->var=rec_flags;
		$$.first=6;
		$$.second=global->rec;
		fprintf(syntax,"\"RECORD\" + Var_list + \"END\" => Record_type\n");
		}
	;

var_list : var_df SEMI var_list {fprintf(syntax,"Var_definition + ; + Var_list => Var_list\n");}
	| var_df SEMI {fprintf(syntax,"Var_definition + ; => Var_list\n");}
	;

var_df :
	id_list
		{
		id_node* tmp;
		int offset;
		if(global->var)
			offset=global->var->offset+get_size(global->var->type,global->var->type_addr);
		else
			offset=0;
		for(id_node*now=(id_node*)($1.second);now;now=tmp)
			{
			int check=1;
			for(flags*fl=global;fl;fl=fl->next)
				{
				if(lookup(fl->con,now->id))
					{
					yyerror("name used in const");
					check=0;
					break;
					}
				if(fl==global&&lookup(fl->var,now->id))
					{
					yyerror("name used in variable");
					check=0;
					break;
					}
				if(lookup(fl->func,now->id))
					{
					yyerror("name used in procedure/function");
					check=0;
					break;
					}
				}
			if(check)
				{
				global->var=new var_node(now->id,1,NULL,offset,global->var);
				offset+=1;
				}
			tmp=now->next;
			delete(now);
			}
		fprintf(syntax,"Identifier_list => Var_definition\n");
		}
	|
	id_list COLON type
		{
		id_node* tmp;
		int offset;
		if(global->var)
			offset=global->var->offset+get_size(global->var->type,global->var->type_addr);
		else
			offset=0;
		int add=get_size($3.first,$3.second);
		for(id_node*now=(id_node*)($1.second);now;now=tmp)
			{
			int check=1;
			for(flags*fl=global;fl;fl=fl->next)
				{
				if(lookup(fl->con,now->id))
					{
					yyerror("name used in const");
					check=0;
					break;
					}
				if(lookup(fl->var,now->id))
					{
					yyerror("name used in variable");
					check=0;
					break;
					}
				if(lookup(fl->func,now->id))
					{
					yyerror("name used in procedure/function");
					check=0;
					break;
					}
				}
			if(check)
				{
				global->var=new var_node(now->id,$3.first,$3.second,offset,global->var);
				offset+=add;
				}
			tmp=now->next;
			delete(now);
			}
		fprintf(syntax,"Identifier_list + : + Type => Var_definition\n");
		}
	;

id_list :
	ID
		{
		$$.first=1;
		$$.second=new id_node($1,NULL);
		fprintf(syntax,"Identifier => Identifier_list\n");
		}
	|
	ID COMMER id_list
		{
		id_node* tmp=new id_node($1,(id_node*)($3.second));
		$$.second=tmp;
		$$.first=$3.first+1;
		fprintf(syntax,"Identifier + , + Identifier_list => Identifier_list\n");
		}
	;

var_dc : VAR var_list {fprintf(syntax,"\"Var\" + Var_list => Var_declaration\n");}
	| {fprintf(syntax,"Var_declaration is empty.\n");}
	;

pro_func_dc : pro_dc SEMI pro_func_dc {fprintf(syntax,"Procedure_declaration + ; + Procedure/Function_declaration-list => Procedure/Function_declaration-list\n");}
	| func_dc SEMI pro_func_dc {fprintf(syntax,"Function_declaration + ; + Procedure/Function_declaration-list => Procedure/Function_declaration-list\n");}
	| pro_dc {fprintf(syntax,"Procedure_declaration => Procedure/Function_declaration-list\n");}
	| func_dc {fprintf(syntax,"Function_declaration => Procedure/Function_declaration-list\n");}
	| {fprintf(syntax,"Procedure/Function_declaration-list is empty.\n");}
	;

pro_dc :
	pro_head SEMI
		{
		$1=code_cnt++;
		code[$1]=instruction(JMP,0,0);
		}
	block
		{
		flags*tmp=global->next;
		delete global;
		global=tmp;
		code[code_cnt++]=instruction(OPR,0,0);
		code[$1].a=code_cnt;
		fprintf(syntax,"Procedure_head + ; + Block => Procedure_declaration\n");
		}
	;

func_dc :
	func_head SEMI
		{
		$1=code_cnt++;
		code[$1]=instruction(JMP,0,0);
		}
	block
		{
		var_node*now=global->var;
		flags*tmp=global->next;
		delete global;
		global=tmp;
		while(strcmp(global->func->id,now->id))
			{
			code[code_cnt++]=instruction(OPR,get_size(now->type,now->type_addr)-1,23);
			now=now->next;
			}
		code[code_cnt++]=instruction(SAVE,get_size(global->func->res_type,global->func->type_addr)-1,0);
		code[code_cnt++]=instruction(OPR,0,0);
		code[$1].a=code_cnt;
		fprintf(syntax,"Function_head + ; + Block => Function_declaration\n");
		}
	;

pro_head :
	PROCEDURE ID
		{
		int check=1;
		for(flags*fl=global;fl;fl=fl->next)
			{
			if(lookup(fl->con,$2))
				{
				yyerror("name used in const");
				check=0;
				break;
				}
			if(lookup(fl->var,$2))
				{
				yyerror("name used in variable");
				check=0;
				break;
				}
			if(lookup(fl->func,$2))
				{
				yyerror("name used in procedure/function");
				check=0;
				break;
				}
			}
		global->func=new func_node($2,7,NULL,0,NULL,code_cnt+1,global->func);
		global=new flags(global);
		}
	LB1 para_list RB1
		{
		global->next->func->para_num=$5.first;
		global->next->func->para=(para_list)($5.second);
		fprintf(syntax,"\"PROCEDURE\" + Identifier + ( + Para_list + )\n => Procedure_head");
		}
	|
	PROCEDURE ID
		{
		int check=1;
		for(flags*fl=global;fl;fl=fl->next)
			{
			if(lookup(fl->con,$2))
				{
				yyerror("name used in const");
				check=0;
				break;
				}
			if(lookup(fl->var,$2))
				{
				yyerror("name used in variable");
				check=0;
				break;
				}
			if(lookup(fl->func,$2))
				{
				yyerror("name used in procedure/function");
				check=0;
				break;
				}
			}
		global->func=new func_node($2,7,NULL,0,NULL,code_cnt+1,global->func);
		global=new flags(global);
		}
	;

func_head :
	FUNCTION ID
		{
		int check=1;
		for(flags*fl=global;fl;fl=fl->next)
			{
			if(lookup(fl->con,$2))
				{
				yyerror("name used in const");
				check=0;
				break;
				}
			if(lookup(fl->var,$2))
				{
				yyerror("name used in variable");
				check=0;
				break;
				}
			if(lookup(fl->func,$2))
				{
				yyerror("name used in procedure/function");
				check=0;
				break;
				}
			}
		global->func=new func_node($2,0,NULL,0,NULL,code_cnt+1,global->func);
		global=new flags(global);
		}
	LB1 para_list RB1 COLON type
		{
		global->next->func->para_num=$5.first;
		global->next->func->para=(para_list)($5.second);
		global->next->func->res_type=$8.first;
		global->next->func->type_addr=$8.second;
		global->var=new var_node($2,$8.first,$8.second,global->var->offset+get_size(global->var->type,global->var->type_addr),global->var);
		fprintf(syntax,"\"FUNCTION\" + Identifier + ( + Para_list + ) + : + Type => Function_head\n");
		}
	|
	FUNCTION ID
		{
		int check=1;
		for(flags*fl=global;fl;fl=fl->next)
			{
			if(lookup(fl->con,$2))
				{
				yyerror("name used in const");
				check=0;
				break;
				}
			if(lookup(fl->var,$2))
				{
				yyerror("name used in variable");
				check=0;
				break;
				}
			if(lookup(fl->func,$2))
				{
				yyerror("name used in procedure/function");
				check=0;
				break;
				}
			}
		global->func=new func_node($2,0,NULL,0,NULL,code_cnt+1,global->func);
		global=new flags(global);
		}
	COLON type
		{
		global->next->func->res_type=$5.first;
		global->next->func->type_addr=$5.second;
		global->var=new var_node($2,$5.first,$5.second,0,global->var);
		fprintf(syntax,"\"FUNCTION\" + Identifier + : + Type => Function_head\n");
		}
	;

para_list :
	para_df SEMI
		{
		$$=$1;
		fprintf(syntax,"Para_definition + ; => Para_list\n");
		}
	|
	para_df SEMI para_list
		{
		para_list now=(para_node*)($1.second);
		while(now->next)now=now->next;
		now->next=(para_node*)($3.second);
		$$.second=$1.second;
		$$.first=$1.first+$3.first;
		fprintf(syntax,"Para_definition + ; + Para_list => Para_list\n");
		}
	;

para_df :
	id_list COLON type
		{
		para_list ret=NULL;
		id_node* tmp;
		int offset;
		if(global->var)
			offset=global->var->offset+get_size(global->var->type,global->var->type_addr);
		else
			offset=0;
		int add=get_size($3.first,$3.second);
		for(id_node*now=(id_node*)($1.second);now;now=tmp)
			{
			int check=1;
			for(flags*fl=global;fl;fl=fl->next)
				{
				if(lookup(fl->con,now->id))
					{
					yyerror("name used in const");
					check=0;
					break;
					}
				if(lookup(fl->var,now->id))
					{
					yyerror("name used in variable");
					check=0;
					break;
					}
				if(lookup(fl->func,now->id))
					{
					yyerror("name used in procedure/function");
					check=0;
					break;
					}
				}
			if(check)
				{
				global->var=new var_node(now->id,$3.first,$3.second,offset,global->var);
				if(ret)
					{
					para_node*iter=ret;
					while(iter->next)iter=iter->next;
					iter->next=new para_node(0,$3.first,$3.second,NULL);
					}
				else
					ret=new para_node(0,$3.first,$3.second,NULL);
				offset+=add;
				}
			tmp=now->next;
			delete(now);
			}
		$$.first=$1.first;
		$$.second=ret;
		fprintf(syntax,"Identifier_list + : + Type => Para_definition\n");
		}
	|
	VAR id_list COLON type
		{
		para_list ret=NULL;
		id_node* tmp;
		int offset;
		if(global->var)
			offset=global->var->offset+get_size(global->var->type,global->var->type_addr);
		else
			offset=0;
		int add=get_size($4.first,$4.second);
		for(id_node*now=(id_node*)($2.second);now;now=tmp)
			{
			int check=1;
			for(flags*fl=global;fl;fl=fl->next)
				{
				if(lookup(fl->con,now->id))
					{
					yyerror("name used in const");
					check=0;
					break;
					}
				if(lookup(fl->var,now->id))
					{
					yyerror("name used in variable");
					check=0;
					break;
					}
				if(lookup(fl->func,now->id))
					{
					yyerror("name used in procedure/function");
					check=0;
					break;
					}
				}
			if(check)
				{
				global->var=new var_node(now->id,$4.first,$4.second,offset,global->var);
				if(ret)
					{
					para_node*iter=ret;
					while(iter->next)iter=iter->next;
					iter->next=new para_node(0,$4.first,$4.second,NULL);
					}
				else
					ret=new para_node(0,$4.first,$4.second,NULL);
				offset+=add;
				}
			tmp=now->next;
			delete(now);
			}
		$$.first=$2.first;
		$$.second=ret;
		fprintf(syntax,"\"VAR\" + Identifier_list + : + Type => Para_definition\n");
		}
	;

statement : BEGINN sentence_seq ENDD {fprintf(syntax,"\"BEGIN\" + Sentence_sequence + \"END\" => Statement\n");}
	| BEGINN ENDD {fprintf(syntax,"\"BEGIN\" + \"END\" => Statement\n");}
	;

sentence_seq : sentence SEMI sentence_seq {fprintf(syntax,"Sentence + ; + Sentence_sequence => Sentence_sequence\n");}
	| sentence {fprintf(syntax,"Sentence => Sentence_sequence\n");}
	| sentence SEMI {fprintf(syntax,"Sentence + ; => Sentence_sequence\n");}
	;

sentence :
	INTEGER COLON
		{
		label_node*tmp=NULL;
		for(flags*fl=global;fl;fl=fl->next)
			{
			tmp=lookup(fl->label,$1);
			if(tmp)break;
			}
		if(tmp)
			tmp->addr=code_cnt;
		else
			yyerror("no such label");
		}
	pure_sen
		{
		fprintf(syntax,"Label + : + Pure_sentence => Sentence\n");
		}
	|
	pure_sen
		{
		fprintf(syntax,"Pure_sentence => Sentence\n");
		}
	;

pure_sen : statement {fprintf(syntax,"Statement => Pure_sentence\n");}
	| assign_sen {fprintf(syntax,"Assign_sentence => Pure_sentence\n");}
	| call_sen {fprintf(syntax,"Call_sentence => Pure_sentence\n");}
	| goto_sen {fprintf(syntax,"Goto_sentence => Pure_sentence\n");}
	| rep_sen {fprintf(syntax,"Repetitive_sentence => Pure_sentence\n");}
	| cond_sen {fprintf(syntax,"Conditional_sentence => Pure_sentence\n");}
	;

goto_sen :
	GOTO INTEGER
		{
		label_node*tmp=NULL;
		for(flags*fl=global;fl;fl=fl->next)
			{
			tmp=lookup(fl->label,$2);
			if(tmp)break;
			}
		if(tmp==NULL)
			yyerror("no such label");
		else if(tmp->addr<0)
			yyerror("label not marked");
		else
			code[code_cnt++]=instruction(JMP,0,tmp->addr);
		fprintf(syntax,"Goto_sentence => \"GOTO\" + Label\n");
		}
	;

assign_sen :
	variable ASSIGN expr
		{
		if($3.first!=$1.type||$3.second!=$1.type_addr)
			yyerror("variable and expression don't have the same type");
		else if($3.first<1||$3.first>4)
			yyerror("not a variable that can be assigned");
		else if($3.first==2)
			code[code_cnt++]=instruction(STOD,$1.l,$1.offset);
		else
			code[code_cnt++]=instruction(STO,$1.l,$1.offset);
		fprintf(syntax,"Assign_sentence => Variable + := + Expression\n");
		}
	|
	variable ASSIGN HAT variable
		{
		if($1.type==0||$1.type!=-$4.type||$1.type_addr!=$4.type_addr)
			yyerror("an illegal usage of pointer");
		else if($1.type<0)
			{
			code[code_cnt++]=instruction(LIT,0,$4.l);
			code[code_cnt++]=instruction(LIT,0,$4.offset);
			code[code_cnt++]=instruction(STOP,$1.l,$1.offset);
			}
		else if($1.type<1||$1.type>4)
			yyerror("not a variable that can be assigned");
		else if($1.type==2)
			{
			code[code_cnt++]=instruction(LODPD,$4.l,$4.offset);
			code[code_cnt++]=instruction(STOD,$1.l,$1.offset);
			}
		else
			{
			code[code_cnt++]=instruction(LODP,$4.l,$4.offset);
			code[code_cnt++]=instruction(STO,$1.l,$1.offset);
			}
		fprintf(syntax,"Variable + := + ^ + Variable => Assign_sentence\n");
		}
	|
	HAT variable ASSIGN expr
		{
		if($2.type!=-$4.first||$2.type_addr!=$4.second)
			yyerror("not a proper pointer");
		else if($4.first<1||$4.first>4)
			yyerror("not a pointer to a type that can be assigned");
		else if($4.first==2)
			code[code_cnt++]=instruction(STOFPD,$2.l,$2.offset);
		else
			code[code_cnt++]=instruction(STOFP,$2.l,$2.offset);
		fprintf(syntax,"^ + Variable + := + Variable => Assign_sentence\n");
		}
	|
	variable ASSIGN NIL
		{
		if($1.type>=0)
			yyerror("not a pointer type");
		else
			{
			code[code_cnt++]=instruction(LIT,0,0);
			code[code_cnt++]=instruction(LIT,0,0);
			code[code_cnt++]=instruction(STOP,$1.l,$1.offset);
			}
		fprintf(syntax,"Variable + := + \"NIL\" => Assign_sentence\n");
		}
	;

variable :
	ID
		{
		var_node*tmp=NULL;
		int level=0;
		for(flags*fl=global;fl;fl=fl->next)
			{
			tmp=lookup(fl->var,$1);
			if(tmp)break;
			++level;
			}
		if(tmp)
			{
			$$.type=tmp->type;
			$$.type_addr=tmp->type_addr;
			$$.l=level;
			$$.offset=tmp->offset;
			}
		else
			{
			const_node*temp=NULL;
			for(flags*fl=global;fl;fl=fl->next)
				{
				temp=lookup(fl->con,$1);
				if(temp)break;
				}
			if(temp)
				{
				$$.type=0;
				$$.type_addr=temp;
				}
			else
				yyerror("no such identifier");
			}
		fprintf(syntax,"Identifier => Variable\n");
		}
	|
	variable DOT ID
		{
		if($1.type!=6)
			yyerror("this variable is not a record type");
		var_node*tmp=lookup(((record_node*)($1.type_addr))->field,$3);
		if(tmp)
			{
			$$.type=tmp->type;
			$$.type_addr=tmp->type_addr;
			$$.l=$1.l;
			$$.offset=$1.offset+tmp->offset;
			}
		else
			yyerror("no such field");
		fprintf(syntax,"Variable + . + Identifier => Variable\n");
		}
	// |
	// variable LB2 integer_const_list RB2
		// {
		// if($1.type!=5)
			// yyerror("this variable is not a array type");
		// else if($3.first!=((array_node*)($1.type_addr))->dim)
			// yyerror("dimension illegal");
		// else
			// {
			// int index=0;
			// int scale=1;
			// vector<int>&vi=((array_node*)($1.type_addr))->index;
			// int_node*now=(int_node*)($3.second);
			// for(int i=0;i<$3.first;++i)
				// {
				// int low=vi[vi.size()-2*i-1];
				// int up=vi[vi.size()-2*i-2];
				// if(now->data>up||now->data<low)
					// yyerror("index out of bound");
				// index+=(now->data-low)*scale;
				// scale*=(up-low+1);
				// int_node*tmp=now->next;
				// delete now;
				// now=tmp;
				// }
			// int type=((array_node*)($1.type_addr))->type;
			// void*type_addr=((array_node*)($1.type_addr))->type_addr;
			// $$.type=type;
			// $$.type_addr=type_addr;
			// $$.l=$1.l;
			// $$.offset=$1.offset+index*get_size(type,type_addr);
			// }
		// fprintf(syntax,"Variable + [ + integer_const_list + ] => Variable");
		// }
	|
	variable LB2 expr_list RB2
		{
		if($1.type!=5)
			yyerror("this variable is not a array type");
		else if($3!=((array_node*)($1.type_addr))->dim)
			yyerror("dimension illegal");
		else
			{
			int type=((array_node*)($1.type_addr))->type;
			void*type_addr=((array_node*)($1.type_addr))->type_addr;
			int scale=get_size(type,type_addr);
			code[code_cnt++]=instruction(LIT,0,$1.offset);
			vector<int>&vi=((array_node*)($1.type_addr))->index;
			for(int i=0;i<$3;++i)
				{
				int low=vi[vi.size()-2*i-1];
				int up=vi[vi.size()-2*i-2];
				code[code_cnt++]=instruction(SAVE,0,0);
				code[code_cnt++]=instruction(LIT,0,low);
				code[code_cnt++]=instruction(OPR,0,3);
				code[code_cnt++]=instruction(LIT,0,scale);
				code[code_cnt++]=instruction(OPR,0,4);
				code[code_cnt++]=instruction(LOAD,0,0);
				code[code_cnt++]=instruction(OPR,0,2);
				scale*=(up-low+1);
				}
			$$.type=type;
			$$.type_addr=type_addr;
			$$.l=$1.l;
			$$.offset=-1;
			}
		fprintf(syntax,"Variable + [ + Expression_list + ] => Variable");
		}
	;

expr_list : expr {$$=1;fprintf(syntax,"Expression => Expression_list\n");}
	| expr COMMER expr_list {$$=$3+1;fprintf(syntax,"Expression + , + Expression_list => Expression_list\n");}
	;

integer_const_list :
	integer_const
		{
		$$.first=1;
		$$.second=new int_node($1,NULL);
		fprintf(syntax,"Integer_const => Integer_const_list\n");
		}
	|
	integer_const_list COMMER integer_const
		{
		$$.first=$1.first+1;
		$$.second=new int_node($3,(int_node*)($1.second));
		fprintf(syntax,"Integer_const_list + , + Integer_const => Integer_const_list\n");
		}
	;

expr :
	simple_expr
		{
		$$=$1;
		fprintf(syntax,"Simple_expression => Expression\n");
		}
	|
	simple_expr EQUAL simple_expr
		{
		$$.first=4;$$.second=NULL;
		if($1.first!=$3.first)
			yyerror("not the same type");
		else if($1.first<1||$1.first>4)
			yyerror("not a type that can be compared");
		else if($1.first==2)
			code[code_cnt++]=instruction(OPR,1,8);
		else
			code[code_cnt++]=instruction(OPR,0,8);
		fprintf(syntax,"Simple_expression + = + Simple_expression => Expression\n");
		}
	|
	simple_expr NOT_EQUAL simple_expr
		{
		$$.first=4;$$.second=NULL;
		if($1.first!=$3.first)
			yyerror("not the same type");
		else if($1.first<1||$1.first>4)
			yyerror("not a type that can be compared");
		else if($1.first==2)
			code[code_cnt++]=instruction(OPR,1,9);
		else
			code[code_cnt++]=instruction(OPR,0,9);
		fprintf(syntax,"Simple_expression + <> + Simple_expression => Expression\n");
		}
	|
	simple_expr LESS simple_expr
		{
		$$.first=4;$$.second=NULL;
		if($1.first!=$3.first)
			yyerror("not the same type");
		else if($1.first<1||$1.first>4)
			yyerror("not a type that can be compared");
		else if($1.first==2)
			code[code_cnt++]=instruction(OPR,1,10);
		else
			code[code_cnt++]=instruction(OPR,0,10);
		fprintf(syntax,"Simple_expression + < + Simple_expression => Expression\n");
		}
	|
	simple_expr G_OR_E simple_expr
		{
		$$.first=4;$$.second=NULL;
		if($1.first!=$3.first)
			yyerror("not the same type");
		else if($1.first<1||$1.first>4)
			yyerror("not a type that can be compared");
		else if($1.first==2)
			code[code_cnt++]=instruction(OPR,1,11);
		else
			code[code_cnt++]=instruction(OPR,0,11);
		fprintf(syntax,"Simple_expression + >= + Simple_expression => Expression\n");
		}
	|
	simple_expr GREATER simple_expr
		{
		$$.first=4;$$.second=NULL;
		if($1.first!=$3.first)
			yyerror("not the same type");
		else if($1.first<1||$1.first>4)
			yyerror("not a type that can be compared");
		else if($1.first==2)
			code[code_cnt++]=instruction(OPR,1,12);
		else
			code[code_cnt++]=instruction(OPR,0,12);
		fprintf(syntax,"Simple_expression + > + Simple_expression => Expression\n");
		}
	|
	simple_expr L_OR_E simple_expr
		{
		$$.first=4;$$.second=NULL;
		if($1.first!=$3.first)
			yyerror("not the same type");
		else if($1.first<1||$1.first>4)
			yyerror("not a type that can be compared");
		else if($1.first==2)
			code[code_cnt++]=instruction(OPR,1,13);
		else
			code[code_cnt++]=instruction(OPR,0,13);
		fprintf(syntax,"Simple_expression + <= + Simple_expression => Expression\n");
		}	
	;

simple_expr :
	sign term_list
		{
		if($1<0)
			{
			if($2.first==1)
				code[code_cnt++]=instruction(OPR,0,1);
			else if($2.first==2)
				code[code_cnt++]=instruction(OPR,1,1);
			else
				yyerror("not a type can be negated");
			}
		$$=$2;
		fprintf(syntax,"Sign + Term_list => Simple_expression\n");
		}
	;

term_list :
	term_list PLUS term
		{
		$$=$1;
		if($1.first!=$3.first)
			yyerror("not the same type");
		else if($1.first==1)
			code[code_cnt++]=instruction(OPR,0,2);
		else if($1.first==2)
			code[code_cnt++]=instruction(OPR,1,2);
		else
			yyerror("not a type can be added");
		fprintf(syntax,"Term_list + Term => Term_list\n");
		}
	|
	term_list MINUS term
		{
		$$=$1;
		if($1.first!=$3.first)
			yyerror("not the same type");
		else if($1.first==1)
			code[code_cnt++]=instruction(OPR,0,3);
		else if($1.first==2)
			code[code_cnt++]=instruction(OPR,1,3);
		else
			yyerror("not a type can be subtracted");
		fprintf(syntax,"Term_list - Term => Term_list\n");
		}
	|
	term_list OR term
		{
		$$=$1;
		if($1.first!=$3.first)
			yyerror("not the same type");
		else if($1.first==1)
			code[code_cnt++]=instruction(OPR,0,17);
		else if($1.first==4)
			code[code_cnt++]=instruction(OPR,1,17);
		else
			yyerror("not a type can be \"or\"");
		fprintf(syntax,"Term_list OR Term => Term_list\n");
		}
	|
	term_list XOR term
		{
		$$=$1;
		if($1.first!=$3.first)
			yyerror("not the same type");
		else if($1.first==1)
			code[code_cnt++]=instruction(OPR,0,18);
		else if($1.first==4)
			code[code_cnt++]=instruction(OPR,1,18);
		else
			yyerror("not a type can be \"xor\"");
		fprintf(syntax,"Term_list XOR Term => Term_list\n");
		}
	|
	term
		{
		$$=$1;
		fprintf(syntax,"Term => Term_list\n");
		}
	;

term :
	factor
		{
		$$=$1;
		fprintf(syntax,"Factor => Term\n");
		}
	|
	term TIME factor
		{
		$$=$1;
		if($1.first!=$3.first)
			yyerror("not the same type");
		else if($1.first==1)
			code[code_cnt++]=instruction(OPR,0,4);
		else if($1.first==2)
			code[code_cnt++]=instruction(OPR,1,4);
		else
			yyerror("not a type can be timed");
		fprintf(syntax,"Term * Factor => Term\n");
		}
	|
	term DIVIDE factor
		{
		$$=$1;
		if($1.first!=$3.first)
			yyerror("not the same type");
		else if($1.first==2)
			code[code_cnt++]=instruction(OPR,1,5);
		else
			yyerror("not a type can be \"/\"");
		fprintf(syntax,"Term / Factor => Term\n");
		}
	|
	term DIV factor
		{
		$$=$1;
		if($1.first!=$3.first)
			yyerror("not the same type");
		else if($1.first==1)
			code[code_cnt++]=instruction(OPR,0,5);
		else
			yyerror("not a type can be \"div\"");
		fprintf(syntax,"Term DIV Factor => Term\n");
		}
	|
	term MOD factor
		{
		$$=$1;
		if($1.first!=$3.first)
			yyerror("not the same type");
		else if($1.first==1)
			code[code_cnt++]=instruction(OPR,0,19);
		else
			yyerror("not a type can be \"mod\"");
		fprintf(syntax,"Term MOD Factor => Term\n");
		}
	|
	term AND factor
		{
		$$=$1;
		if($1.first!=$3.first)
			yyerror("not the same type");
		else if($1.first==1)
			code[code_cnt++]=instruction(OPR,0,20);
		else if($1.first==4)
			code[code_cnt++]=instruction(OPR,1,20);
		else
			yyerror("not a type can be \"and\"");
		fprintf(syntax,"Term_list AND Term => Term_list\n");
		}
	;

factor :
	NOT factor
		{
		$$=$2;
		if($2.first==1)
			code[code_cnt++]=instruction(OPR,0,21);
		else if($2.first==4)
			code[code_cnt++]=instruction(OPR,1,21);
		else
			yyerror("not a type can be \"not\"");
		fprintf(syntax,"NOT Factor => Factor\n");
		}
	|
	LB1 expr RB1
		{
		$$=$2;
		fprintf(syntax,"( + Expression + ) => Factor\n");
		}
	|
	variable
		{
		$$.first=$1.type;
		$$.second=$1.type_addr;
		if($1.type==0)
			{
			const_node*tmp=(const_node*)($1.type_addr);
			$$.first=tmp->type;
			$$.second=NULL;
			if(tmp->type==1)
				code[code_cnt++]=instruction(LIT,0,tmp->val);
			else
				code[code_cnt++]=instruction(LIT,1,tmp->double_val);
			}
		else if($1.type<1||$1.type>4)
			yyerror("not a variable can be used as an expression");
		else if($1.type==2)
			code[code_cnt++]=instruction(LODD,$1.l,$1.offset);
		else
			code[code_cnt++]=instruction(LOD,$1.l,$1.offset);
		fprintf(syntax,"Variable => Factor\n");
		}
	|
	INTEGER
		{
		$$.first=1;
		$$.second=NULL;
		code[code_cnt++]=instruction(LIT,0,$1);
		fprintf(syntax,"Integer => Factor\n");
		}
	|
	REAL
		{
		$$.first=2;
		$$.second=NULL;
		code[code_cnt++]=instruction(LIT,1,$1);
		fprintf(syntax,"Real => Factor\n");
		}
	|
	BOOL
		{
		$$.first=4;
		$$.second=NULL;
		code[code_cnt++]=instruction(LIT,0,$1);
		fprintf(syntax,"Boolean => Factor\n");
		}
	|
	CHAR
		{
		$$.first=3;
		$$.second=NULL;
		code[code_cnt++]=instruction(LIT,0,$1);
		fprintf(syntax,"Char => Factor\n");
		}
	|
	function_expr
		{
		$$=$1;
		fprintf(syntax,"Function_expression => Factor\n");
		}
	;

rep_sen :
	WHILE
		{
		$1=code_cnt;
		}
	expr DO
		{
		if($3.first!=4)
			yyerror("expected a boolean type");
		else
			{
			$4=code_cnt++;
			code[$4]=instruction(JPC,0,0);
			}
		}
	statement
		{
		code[code_cnt++]=instruction(JMP,0,$1);
		code[$4].a=code_cnt;
		fprintf(syntax,"\"WHILE\" + Expression + \"DO\" + Statement => Repetitive_sentence\n");
		}
	|
	REPEAT
		{
		$1=code_cnt;
		}
	sentence_seq UNTIL expr
		{
		if($5.first!=4)
			yyerror("expected a boolean type");
		else
			code[code_cnt++]=instruction(JPC,0,$1);
		fprintf(syntax,"\"REPEAT\" + Sentence_sequence + \"UNTIL\" + Expression => Repetitive_sentence\n");
		}
	|
	FOR variable ASSIGN expr TO
		{
		if($2.type!=1||$4.first!=1)
			yyerror("not integer type");
		else
			code[code_cnt++]=instruction(STO,$2.l,$2.offset);
		$1=code_cnt;
		}
	expr DO
		{
		if($7.first!=1)
			yyerror("not integer type");
		else
			{
			code[code_cnt++]=instruction(LOD,$2.l,$2.offset);
			code[code_cnt++]=instruction(OPR,0,11);
			$8=code_cnt++;
			code[$8]=instruction(JPC,0,0);
			}
		}
	statement
		{
		code[code_cnt++]=instruction(LOD,$2.l,$2.offset);
		code[code_cnt++]=instruction(LIT,0,1);
		code[code_cnt++]=instruction(OPR,0,2);
		code[code_cnt++]=instruction(STO,$2.l,$2.offset);
		code[code_cnt++]=instruction(JMP,0,$1);
		code[$8].a=code_cnt;
		fprintf(syntax,"\"FOR\" + Variable + := + Expression + \"TO\" + Expression + \"DO\" + Statement => Repetitive_sentence\n");
		}
	|
	FOR variable ASSIGN expr DOWNTO
		{
		if($2.type!=1||$4.first!=1)
			yyerror("not integer type");
		else
			code[code_cnt++]=instruction(STO,$2.l,$2.offset);
		$1=code_cnt;
		}
	expr DO
		{
		if($7.first!=1)
			yyerror("not integer type");
		else
			{
			code[code_cnt++]=instruction(LOD,$2.l,$2.offset);
			code[code_cnt++]=instruction(OPR,0,13);
			$8=code_cnt++;
			code[$8]=instruction(JPC,0,0);
			}
		}
	statement
		{
		code[code_cnt++]=instruction(LOD,$2.l,$2.offset);
		code[code_cnt++]=instruction(LIT,0,1);
		code[code_cnt++]=instruction(OPR,0,3);
		code[code_cnt++]=instruction(STO,$2.l,$2.offset);
		code[code_cnt++]=instruction(JMP,0,$1);
		code[$8].a=code_cnt;
		fprintf(syntax,"\"FOR\" + Variable + := + Expression + \"DOWNTO\" + Expression + \"DO\" + Statement => Repetitive_sentence\n");
		}
	;

cond_sen :
	IF expr THEN
		{
		if($2.first!=4)
			yyerror("expected a bolean type");
		else
			{
			$3=code_cnt++;
			code[$3]=instruction(JPC,0,0);
			}
		}
	statement
		{
		code[$3].a=code_cnt+1;
		$3=code_cnt++;
		code[$3]=instruction(JMP,0,0);
		}
	else_sen
		{
		code[$3].a=code_cnt;
		fprintf(syntax,"\"IF\" + Expression + \"THEN\" + Statement + Else_sentence => Conditional_sentence\n");
		}
	| 
	CASE expr
		{
		if($2.first!=1)
			yyerror("not integer type");
		}
	OF case_list ENDD
		{
		code[code_cnt++]=instruction(OPR,0,23);
		int_node*now=(int_node*)($5.second);
		int_node*tmp;
		for(int i=0;i<$5.first;++i)
			{
			code[now->data].a=code_cnt;
			tmp=now->next;
			delete now;
			now=tmp;
			}
		fprintf(syntax,"\"CASE\" + Expression + \"OF\" + Case_list + \"END\" => Conditional_sentence\n");
		}
	;

else_sen : {fprintf(syntax,"Else_sentence is empty.\n");}
	| ELSE statement {fprintf(syntax,"\"ELSE\" + Statement => Else_sentence\n");}
	;

case_list :
	case_df SEMI
		{
		$$.first=1;
		$$.second=new int_node($1,NULL);
		fprintf(syntax,"Case_definition + ; => Case_list\n");
		}
	|
	case_df SEMI case_list
		{
		$$.first=$3.first+1;
		$$.second=new int_node($1,(int_node*)($3.second));
		fprintf(syntax,"Case_df + ; + Case_list\n => Case_list");
		}
	|
	ELSE statement SEMI
		{
		$$.first=0;
		$$.second=NULL;
		fprintf(syntax,"\"ELSE\" + Statement\n => Case_list");
		}		
	;

case_df :
	integer_const_list COLON
		{
		int addr=code_cnt+3*$1.first+2;
		int_node*tmp;
		int_node*now=(int_node*)($1.second);
		for(int i=0;i<$1.first;++i)
			{
			code[code_cnt++]=instruction(LIT,0,now->data);
			code[code_cnt++]=instruction(OPR,0,22);
			code[code_cnt++]=instruction(JPC,0,addr);
			tmp=now->next;
			delete now;
			now=tmp;		
			}
		code[code_cnt++]=instruction(SAVE,0,0);
		$1.first=code_cnt++;
		code[$1.first]=instruction(JMP,0,0);
		}
	statement
		{
		$$=code_cnt;
		code[code_cnt++]=instruction(JMP,0,0);
		code[$1.first].a=code_cnt;
		code[code_cnt++]=instruction(LOAD,0,0);
		fprintf(syntax,"Integer_const_list + : + Statement => Case_definition\n");
		}
	;

call_sen :
	CALL ID
		{
		func_node*tmp=NULL;
		int level=0;
		for(flags*fl=global;fl;fl=fl->next)
			{
			tmp=lookup(fl->func,$2);
			if(tmp)break;
			++level;
			}
		if(tmp==NULL)
			yyerror("no such procedure");
		else if(tmp->para_num)
			yyerror("too many or too few parameters");
		else if(tmp->res_type!=7)
			yyerror("not a procedure but a function");
		else
			code[code_cnt++]=instruction(CAL,level,tmp->addr);
		fprintf(syntax,"\"CALL\" + Identifier\n => Call_sentence");
		}
	|
	ID LB1 actual_para_list RB1
		{
		func_node*tmp=NULL;
		int level=0;
		for(flags*fl=global;fl;fl=fl->next)
			{
			tmp=lookup(fl->func,$1);
			if(tmp)break;
			++level;
			}
		if(tmp==NULL)
			yyerror("no such procedure");
		else if ($3.first!=tmp->para_num)
			yyerror("too many or too few parameters");
		else if(tmp->res_type!=7)
			yyerror("not a procedure but a function");
		else
			{
			int size=0;
			para_node*now=(para_node*)($3.second);
			para_node*temp;
			para_node*std=tmp->para;
			for(int i=0;i<$3.first;++i)
				{
				if(now->type!=std->type||now->type_addr!=std->type_addr)
					yyerror("wrong parameter type");
				temp=now->next;
				delete now;
				now=temp;
				size+=get_size(std->type,std->type_addr);
				std=std->next;
				}
			code[code_cnt++]=instruction(CAL,level,tmp->addr,size);
			}
		fprintf(syntax,"Identifier + ( + Actual_para_list + ) => Call_sentence\n");
		}
	|
	READ LB1 variable RB1
		{
		if($3.type<1||$3.type>4)
			yyerror("a type that can't be readed");
		else if($3.type==2)
			{
			code[code_cnt++]=instruction(OPR,1,16);
			code[code_cnt++]=instruction(STOD,$3.l,$3.offset);
			}
		else
			{
			code[code_cnt++]=instruction(OPR,0,16);
			code[code_cnt++]=instruction(STO,$3.l,$3.offset);
			}
		fprintf(syntax,"\"READ\" + ( + Variable + ) => Call_sentence\n");
		}
	|
	WRITE LB1 expr RB1
		{
		if($3.first==1)
			code[code_cnt++]=instruction(OPR,0,14);
		else if($3.first==2)
			code[code_cnt++]=instruction(OPR,1,14);
		else if($3.first==3)
			code[code_cnt++]=instruction(OPR,2,14);
		else if($3.first==4)
			code[code_cnt++]=instruction(OPR,3,14);
		else
			yyerror("a type that can't be printed");
		fprintf(syntax,"\"WRITE\" + ( + Expression + ) => Call_sentence\n");
		}
	|
	WRITELN LB1 RB1
		{
		code[code_cnt++]=instruction(OPR,0,15);
		fprintf(syntax,"\"WRITELN\" + ( + ) => Call_sentence\n");
		}
	|
	WRITELN LB1 expr RB1
		{
		if($3.first==1)
			code[code_cnt++]=instruction(OPR,0,14);
		else if($3.first==2)
			code[code_cnt++]=instruction(OPR,1,14);
		else if($3.first==3)
			code[code_cnt++]=instruction(OPR,2,14);
		else if($3.first==4)
			code[code_cnt++]=instruction(OPR,3,14);
		else
			yyerror("a type that can't be printed");
		code[code_cnt++]=instruction(OPR,0,15);
		fprintf(syntax,"\"WRITELN\" + ( + Expression + ) => Call_sentence\n");
		}	
	;

actual_para_list :
	expr
		{
		$$.first=1;
		$$.second=new para_node(0,$1.first,$1.second,NULL);
		fprintf(syntax,"Expression => Actual_para_list\n");
		}
	|
	expr COMMER actual_para_list
		{
		$$.first=$3.first+1;
		$$.second=new para_node(0,$1.first,$1.second,(para_node*)($3.second));
		fprintf(syntax,"Expression + , + Actual_para_list => Actual_para_list\n");
		}
	;

function_expr :
	ID LB1 RB1
		{
		func_node*tmp=NULL;
		int level=0;
		for(flags*fl=global;fl;fl=fl->next)
			{
			tmp=lookup(fl->func,$1);
			if(tmp)break;
			++level;
			}
		if(tmp==NULL)
			yyerror("no such function");
		else if (tmp->para_num)
			yyerror("too many or too few parameters");
		else if (tmp->res_type==7)
			yyerror("not a function but a procedure");
		else
			{
			code[code_cnt++]=instruction(CAL,level,tmp->addr);
			code[code_cnt++]=instruction(LOAD,get_size(tmp->res_type,tmp->type_addr)-1,0);
			$$.first=tmp->res_type;
			$$.second=tmp->type_addr;
			}
		fprintf(syntax,"Identifier + ( + Actual_para_list + ) => Function_expression\n");
		}
	|
	ID LB1 actual_para_list RB1
		{
		func_node*tmp=NULL;
		int level=0;
		for(flags*fl=global;fl;fl=fl->next)
			{
			tmp=lookup(fl->func,$1);
			if(tmp)break;
			++level;
			}
		if(tmp==NULL)
			yyerror("no such function");
		else if ($3.first!=tmp->para_num)
			yyerror("too many or too few parameters");
		else if (tmp->res_type==7)
			yyerror("not a function but a procedure");
		else
			{
			int size=0;
			para_node*now=(para_node*)($3.second);
			para_node*temp;
			para_node*std=tmp->para;
			for(int i=0;i<$3.first;++i)
				{
				if(now->type!=std->type||now->type_addr!=std->type_addr)
					yyerror("wrong parameter type");
				temp=now->next;
				delete now;
				now=temp;
				size+=get_size(std->type,std->type_addr);
				std=std->next;
				}
			code[code_cnt++]=instruction(CAL,level,tmp->addr,size);
			code[code_cnt++]=instruction(LOAD,get_size(tmp->res_type,tmp->type_addr)-1,0);
			$$.first=tmp->res_type;
			$$.second=tmp->type_addr;
			}
		fprintf(syntax,"Identifier + ( + Actual_para_list + ) => Function_expression\n");
		}
	|
	ODD LB1 expr RB1
		{
		if($3.first!=1)
			yyerror("not integer type");
		code[code_cnt++]=instruction(OPR,0,6);
		$$.first=4;
		$$.second=NULL;
		fprintf(syntax,"\"ODD\" + ( + Expression + ) => Function_expression\n");
		}
	// |
	// READ LB1 RB1
		// {
		// code[code_cnt++]=instruction(OPR,0,16);
		// $$.first=1;
		// $$.second=NULL;
		// fprintf(syntax,"\"READ\" + ( + ) => Function_expression\n");
		// }
	// |
	// READDB LB1 RB1
		// {
		// code[code_cnt++]=instruction(OPR,1,16);
		// $$.first=2;
		// $$.second=NULL;
		// fprintf(syntax,"\"READDB\" + ( + ) => Function_expression\n");
		// }
	;

%%

int main(int argc,char**argv)
{
	syntax=fopen("syntax.out","w");
	if(argc>1)
		yyin=fopen(argv[1],"r");
	yyparse();
	fclose(yyin);
	if(error_flag==0)interpret();
	return 0;
}
